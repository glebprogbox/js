<!DOCTYPE html>
<html lang="ru">
<meta charset="UTF-8">
<body>
<p>Есть восемь основных типов данных в JavaScript</p>
<p>Переменная в JavaScript может содержать любые данные. В один момент там может быть строка, а в другой – число
  // Не будет ошибкой
  let message = "hello";
  message = 123456;
  Языки программирования, в которых такое возможно, называются «динамически типизированными».
  Это значит, что типы данных есть, но переменные не привязаны ни к одному из них.
</p>
<p>1. Число. Числовой тип данных (number) представляет как целочисленные значения, так и числа с плавающей точкой.
  Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к
  этому типу данных: Infinity, -Infinity и NaN.
  Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.
  Мы можем получить его в результате деления на ноль, или задать его явно:
  alert( Infinity ); // Infinity
  NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:
  alert( "не число" / 2 ); // NaN, такое деление является ошибкой
  Значение NaN «прилипчиво». Любая математическая операция с NaN возвращает NaN:
  alert( NaN + 1 ); // NaN
  alert( 3 * NaN ); // NaN
  alert( "не число" / 2 - 1 ); // NaN
  Если где-то в математическом выражении есть NaN, то оно распространяется на весь результат
  (есть только одно исключение: NaN ** 0 равно 1).
  </p>
<p>
  Математические операции – безопасны
  Математические операции в JavaScript «безопасны». Мы можем делать что угодно: делить на ноль, обращаться с нечисловыми строками как с числами и т.д.
  Скрипт никогда не остановится с фатальной ошибкой (не «умрёт»). В худшем случае мы получим NaN как результат выполнения.
</p>
<p>2. Большие числа. В JavaScript тип number не может безопасно работать с числами, большими, чем (253-1)
  (т. е. 9007199254740991) или меньшими, чем -(253-1) для отрицательных чисел.
  Если говорить совсем точно, то, технически, тип number может хранить большие целые числа (до 1.7976931348623157 * 10308),
  но за пределами безопасного диапазона целых чисел ±(253-1) будет ошибка точности, так как не все цифры помещаются
  в фиксированную 64-битную память. Поэтому можно хранить «приблизительное» значение.
  Например, эти два числа (прямо за пределами безопасного диапазона) совпадают:
  console.log(9007199254740991 + 1); // 9007199254740992
  console.log(9007199254740991 + 2); // 9007199254740992
</p>
<p> // символ "n" в конце означает, что это BigInt
  const bigInt = 1234567890123456789012345678901234567890n;
</p>
<p>В данный момент BigInt поддерживается только в браузерах Firefox, Chrome, Edge и Safari, но не поддерживается в IE.
</p>
<p> 3. Строка. Должна быть заключена в кавычки.
  В JavaScript существует три типа кавычек.
  Двойные кавычки: "Привет".
  Одинарные кавычки: 'Привет'.
  Обратные кавычки: `Привет`.
</p>
<p>
  Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript
  Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}. Например:
  let name = "Иван";
  // Вставим переменную
  alert( `Привет, ${name}!` ); // Привет, Иван!
  // Вставим выражение
  alert( `результат: ${1 + 2}` ); // результат: 3
  Обратите внимание, что это можно делать только в обратных кавычках. Другие кавычки не имеют такой функциональности встраивания!
  alert( "результат: ${1 + 2}" ); // результат: ${1 + 2} (двойные кавычки ничего не
</p>
<p>
  Нет отдельного типа данных для одного символа.
  В некоторых языках, например C и Java, для хранения одного символа, например "a" или "%", существует отдельный тип. В языках C и Java это char.
  В JavaScript подобного типа нет, есть только тип string. Строка может содержать ноль символов (быть пустой), один символ или множество.
</p>
<p>4. Boolean. Булевый тип (boolean) может принимать только два значения: true (истина) и false (ложь).
  Такой тип, как правило, используется для хранения значений да/нет: true значит «да, правильно», а false значит «нет, не правильно».
  Например:
  let nameFieldChecked = true; // да, поле отмечено
  let ageFieldChecked = false; // нет, поле не отмечено
  Булевые значения также могут быть результатом сравнений:
  let isGreater = 4 > 1;
  alert( isGreater ); // true (результатом сравнения будет "да")
</p>
<p>5. Null
  Специальное значение null не относится ни к одному из типов, описанных выше.
  Оно формирует отдельный тип, который содержит только значение null:
  let age = null;
  В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.
  Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».</p>
<p> 6. Undefined
  Специальное значение undefined также стоит особняком. Оно формирует тип из самого себя так же, как и null.
  Оно означает, что «значение не было присвоено».
  Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined:
  let age;
  alert(age); // выведет "undefined"
  Технически мы можем присвоить значение undefined любой переменной:
  let age = 123;
  // изменяем значение на undefined
  age = undefined;
  alert(age); // "undefined"
  …Но так делать не рекомендуется. Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения,
  а undefined – для проверок, была ли переменная назначена.</p>
<p> 7. Тип Object
  Тип object (объект) – особенный.
  Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения
  будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.
</p>
<p> 8. Тип Symbol
  Тип symbol (символ) используется для создания уникальных идентификаторов в объектах.
Примитивный тип, но всегда уникален, даже если создавать несколько с одинаковым описанием
Нужен для скрытых свойств объекта, для системных методов (например итерация объектов)
  Ключевая идея: Symbol — это уникальный ключ, который нельзя случайно перезаписать и нельзя сравнить по содержимому с другим Symbol.</p>
<p> Оператор typeof
Возвращает тип аргумента
  полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку

  У него есть две синтаксические формы:

  // Обычный синтаксис
  typeof 5 // Выведет "number"
  // Синтаксис, напоминающий вызов функции (встречается реже)
  typeof(5) // Также выведет "number"

Если внутри выражение, пишем в скобках (тк у тайпоф выше приоритет чем у бинарных операций +-* и тп)
  typeof 50 + " Квартир"; // Выведет "number Квартир"
  typeof (50 + " Квартир"); // Выведет "string"
</p>
<p> Примеры typeof
  typeof undefined // "undefined"
  typeof 0 // "number"
  typeof 10n // "bigint"
  typeof true // "boolean"
  typeof "foo" // "string"
  typeof Symbol("id") // "symbol"
  typeof Math // "object"  (1)
  typeof null // "object"  (2)
  typeof alert // "function"  (3)</p>
<p>Math — это встроенный объект, который предоставляет математические операции и константы. Здесь он служит лишь примером объекта.
  Результатом вызова typeof null является "object". Это официально признанная ошибка в typeof, ведущая начало с времён
  создания JavaScript и сохранённая для совместимости. Конечно, null не является объектом. Это специальное значение с отдельным типом.
  Вызов typeof alert возвращает "function", потому что alert является функцией. Мы изучим функции в следующих главах,
  где заодно увидим, что в JavaScript нет специального типа «функция». Функции относятся к объектному типу. Но
  typeof обрабатывает их особым образом, возвращая "function". Так тоже повелось от создания JavaScript. Формально
  это неверно, но может быть удобным на практике.
</p>
<p>Итого
  В JavaScript есть 8 основных типов данных.

  Семь из них называют «примитивными» типами данных:
  number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
  bigint для целых чисел произвольной длины.
  string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
  boolean для true/false.
  null для неизвестных значений – отдельный тип, имеющий одно значение null.
  undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
  symbol для уникальных идентификаторов.
  И один не является «примитивным» и стоит особняком:
  object для более сложных структур данных.
  Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.

  Имеет две формы: typeof x или typeof(x).
  Возвращает строку с именем типа. Например, "string".
  Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.</p>
</body>
</html>