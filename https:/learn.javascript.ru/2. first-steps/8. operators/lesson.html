<!DOCTYPE html>
<html lang="ru">
<meta charset="UTF-8">
<body>
<p> Сначала разберёмся с терминологией.
  Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».
  Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный: x = -x;
</p>
<p>
  Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:
  let x = 1, y = 3;
  alert( y - x ); // 2, бинарный минус вычитает значения
</p>
<p>
  Поддерживаются следующие математические операторы:

  Сложение +,
  Вычитание -,
  Умножение *,
  Деление /,
  Взятие остатка от деления %,
  Возведение в степень **.
  Первые четыре оператора очевидны, а про % и ** стоит сказать несколько слов.


</p>
<p>
  Оператор взятия остатка %, несмотря на обозначение, никакого отношения к процентам не имеет.

  Результат a % b – это остаток от целочисленного деления a на b.

  Например:

  alert( 5 % 2 ); // 1, остаток от деления 5 на 2
  alert( 8 % 3 ); // 2, остаток от деления 8 на 3
  alert( 8 % 4 ); // 0, остаток от деления 8 на 4
</p>
<p>
  Обычно при помощи плюса '+' складывают числа.

  Но если бинарный оператор '+' применить к строкам, то он их объединяет в одну:

  let s = "моя" + "строка";
  alert(s); // моястрока
  Обратите внимание, если хотя бы один операнд является строкой, то второй будет также преобразован в строку.

  Например:

  alert( '1' + 2 ); // "12"
  alert( 2 + '1' ); // "21"
  Как видите, не важно, первый или второй операнд является строкой.

  Вот пример посложнее:

  alert(2 + 2 + '1' ); // будет "41", а не "221"
  Здесь операторы работают один за другим. Первый + складывает два числа и возвращает 4, затем следующий + объединяет результат со строкой, производя действие 4 + '1' = '41'.

  Сложение и преобразование строк — это особенность бинарного плюса +. Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.
  Например, вычитание и деление:

  alert( 6 - '2' ); // 4, '2' приводится к числу
  alert( '6' / '2' ); // 3, оба операнда приводятся к числам
</p>

<p>
  Плюс + существует в двух формах: бинарной, которую мы использовали выше, и унарной.

  Унарный, то есть применённый к одному значению, плюс + ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число.

  Например:

  // Не влияет на числа
  let x = 1;
  alert( +x ); // 1

  let y = -2;
  alert( +y ); // -2

  // Преобразует не числа в числа
  alert( +true ); // 1
  alert( +"" );   // 0
  На самом деле это то же самое, что и Number(...), только короче.

  Необходимость преобразовывать строки в числа возникает очень часто. Например, обычно значения полей HTML-формы — это строки. А что, если их нужно, к примеру, сложить?

  Бинарный плюс сложит их как строки:

  let apples = "2";
  let oranges = "3";

  alert( apples + oranges ); // "23", так как бинарный плюс объединяет строки
  Поэтому используем унарный плюс, чтобы преобразовать к числу:

  let apples = "2";
  let oranges = "3";

  // оба операнда предварительно преобразованы в числа
  alert( +apples + +oranges ); // 5

  // более длинный вариант
  // alert( Number(apples) + Number(oranges) ); // 5
  С точки зрения математики, такое изобилие плюсов выглядит странным. Но с точки зрения программиста тут нет ничего особенного: сначала выполнятся унарные плюсы, которые приведут строки к числам, а затем бинарный '+' их сложит.

  Почему унарные плюсы выполнились до бинарного сложения? Как мы сейчас увидим, дело в их приоритете.
</p>
<p>
  Давайте отметим, что в таблице приоритетов также есть оператор присваивания =. У него один из самых низких приоритетов: 2.
  Именно поэтому, когда переменной что-либо присваивают, например, x = 2 * 2 + 1, то сначала выполнится арифметика, а уже затем произойдёт присваивание = с сохранением результата в x.
  let x = 2 * 2 + 1;
  alert( x ); // 5

</p>
<p>
  Большинство операторов в JavaScript возвращают значение. Для некоторых это очевидно, например сложение + или умножение *. Но и оператор присваивания не является исключением.

  Вызов x = value записывает value в x и возвращает его.

  Благодаря этому присваивание можно использовать как часть более сложного выражения:

  let a = 1;
  let b = 2;

  let c = 3 - (a = b + 1);

  alert( a ); // 3
  alert( c ); // 0
</p>
<p> Сокращённая арифметика с присваиванием
  Часто нужно применить оператор к переменной и сохранить результат в ней же.

  Например:

  let n = 2;
  n = n + 5;
  n = n * 2;
  Эту запись можно укоротить при помощи совмещённых операторов += и *=:

  let n = 2;
  n += 5; // теперь n = 7 (работает как n = n + 5)
  n *= 2; // теперь n = 14 (работает как n = n * 2)

  alert( n ); // 14
  Подобные краткие формы записи существуют для всех арифметических и побитовых операторов: /=, -=, **= и так далее.

  Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций:

  let n = 2;

  n *= 3 + 5;

  alert( n ); // 16  (сначала выполнится правая часть, выражение идентично n *= 8)</p>
<p>
  Инкремент/декремент
  Одной из наиболее частых числовых операций является увеличение или уменьшение на единицу.

  Для этого существуют даже специальные операторы:

  Инкремент ++ увеличивает переменную на 1:

  let counter = 2;
  counter++;        // работает как counter = counter + 1, просто запись короче
  alert( counter ); // 3
  Декремент -- уменьшает переменную на 1:

  let counter = 2;
  counter--;        // работает как counter = counter - 1, просто запись короче
  alert( counter ); // 1
  Важно:
  Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведёт к ошибке.
  Как мы знаем, все операторы возвращают значение. Операторы инкремента/декремента не исключение
</p>
<p>
  Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа).

  Чтобы увидеть разницу, вот небольшой пример:

  let counter = 1;
  let a = ++counter; // (*)

  alert(a); // 2
  В строке (*) префиксная форма ++counter увеличивает counter и возвращает новое значение 2. Так что alert покажет 2.

  Теперь посмотрим на постфиксную форму:

  let counter = 1;
  let a = counter++; // (*) меняем ++counter на counter++

  alert(a); // 1
  В строке (*) постфиксная форма counter++ также увеличивает counter, но возвращает старое значение (которое было до увеличения). Так что alert покажет 1.
</p>
<p>
  Побитовые операторы работают с 32-разрядными целыми числами (при необходимости приводят к ним), на уровне их внутреннего двоичного представления.

  Эти операторы не являются чем-то специфичным для JavaScript, они поддерживаются в большинстве языков программирования.

  Поддерживаются следующие побитовые операторы:

  AND(и) ( & )
  OR(или) ( | )
  XOR(побитовое исключающее или) ( ^ )
  NOT(не) ( ~ )
  LEFT SHIFT(левый сдвиг) ( << )
  RIGHT SHIFT(правый сдвиг) ( >> )
  ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )
  Используются редко, например, в криптографии.
</p>
<p>
  Оператор «запятая»
  Оператор «запятая» (,) редко применяется и является одним из самых необычных. Иногда он используется для написания более короткого кода, поэтому нам нужно знать его, чтобы понимать, что при этом происходит.

  Оператор «запятая» предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ,. Каждое выражение выполняется, но возвращается результат только последнего.

  Например:

  let a = (1 + 2, 3 + 4);

  alert( a ); // 7 (результат вычисления 3 + 4)
  Первое выражение 1 + 2 выполняется, а результат отбрасывается. Затем идёт 3 + 4, выражение выполняется и возвращается результат.
  Зачем нам оператор, который отбрасывает всё, кроме последнего выражения?

  Иногда его используют в составе более сложных конструкций, чтобы сделать несколько действий в одной строке.

  Например:

  // три операции в одной строке
  for (a = 1, b = 3, c = a * b; a < 10; a++) {
  ...
  }
  Такие трюки используются во многих JavaScript-фреймворках. Вот почему мы упоминаем их. Но обычно они не улучшают читабельность кода, поэтому стоит хорошо подумать, прежде чем их использовать.

</p>
</body>
</html>